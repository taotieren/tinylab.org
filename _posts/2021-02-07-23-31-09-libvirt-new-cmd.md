---
layout: post
author: 'Gao Chengbo'
title: "一文介绍如何给 libvirt 添加一个新的 virsh 命令"
top: false
draft: true
license: "cc-by-nc-nd-4.0"
permalink: /libvirt-new-cmd/
description: "本文介绍了如何给 libvirt 添加一个新的 virsh 命令，也介绍了添加一个 RPC 调用。"
category:
  - 虚拟化

tags:
  - libvirt
  - Qemu
---

>
> By 高承博 金琦 刘唐 of [TinyLab.org](http://tinylab.org)
> 2020/01/01
>

## libvirt 简介

libvirt 是用于管理虚拟化平台的开源API、后台程序和管理工具。它对上层云管平台提供一套 API 接口，libvirt 也自带了一个 virsh 工具可以用来控制虚机的生命周期，包括创建、删除、修改虚机。

本文中使用的 libvirt 版本为 4.0.0。
    

## libvirt API 的增添

目前 libvirt 已经提供了强大的 API 支持，但由于云上环境比较复杂，有时需要新定义一个 libvirt API 接口。

由于每添加一个 API 接口几乎就要添加一个新的 RPC 调用，所以添加的文件非常多。笔者已经添加了好几个新的 API 接口，但每次总以为自己能够把所有文件都记住而没有记笔记，但事实证明好脑瓜不如烂笔头。

以增添一个 `cmdHelloWorld` 为例，总共包括以下步骤：

1. virsh 命令的添加
2. API 接口的添加
3. RPC 的添加
    
由于添加 API 接口的步骤过长，本文先给大家介绍如何添加一个新的 virsh 命令。

## 增添一个 virsh 命令

所有 virsh 命令的相应函数及其后传递的命令行参数都是在 `virsh-domain.c` 中。

virsh 命令是指 virsh 后面跟的第一个命令行参数。本文我们以 `virsh helloworld` 为例教大家如何添加一个 helloworld 命令。

### 增添 helloworld 函数 cmdHelloWorld

命令的响应函数是 `cmdHelloWorld`。也就是执行 `virsh helloworld` 后将调用的函数。

这个函数由 virsh 进程调用，最终调用 `cmdHelloWorld`。

`cmdHelloWorld` 再调用 RPC 与计算结点的守护进程 libvirtd 交互。

### 为 helloworld 增添新的命令行参数

`virsh helloworld` 后我们设置了以下几个命令行参数：

* `--local`：表示与本地的 libvirtd 相连。
* `--help`：显示帮助信息。

libvirt 描述命令行参数是用 `vshCmdOptDef` 数组表示，也就是 `--local` 要添加到 `vshCmdOptDef` 数组中。

而 `virsh helloworld --help` 要显示的信息添加到 `vshCmdInfo` 数组中。

### 相应实现

#### 命令行参数实现
 
    static const vshCmdInfo info_helloworld[] = {
      {.name = "help",
      .data = N_("Print Hello World")
      },
      {.name = NULL}
    };
    static const vshCmdOptDef opts_helloworld[] = {
      {.name = "local",
      .type = VSH_OT_BOOL,
      .help = N_("print Hello World in local.")
      },
      {.name = NULL}
    };

`vshCmdOptDef opts_helloworld[]`：表示的是 `virsh helloworld` 后要接的两个命令行参数的描述。
`vshCmdInfo info_helloworld[]`: 是 `virsh helloworld --help` 所显示的描述打印。

#### cmdHelloWorld 实现

为了让示例程序最简单化，我们把virsh helloworld 的工作就是打印hello world字符串。

    static bool
    cmdHelloWorld(vshControl *ctl, const vshCmd *cmd)
    {
      bool ret = false;
      char *buffer;

      if (!vshCommandOptBool(cmd, "local"))
        goto cleanup;

      vshPrintExtra(ctl, _("Hello World\n")); 

      ret = true;

    cleanup:

      return ret;
    }
    
#### 把 helloworld 命令添加进 vshCmdDef domManagementCmds[] 中

virsh 命令的命令行和处理函数都要注册到 `domManagementCmds[]` 中。

我们把刚刚添加的数据结构 `vshCmdOptDef`、`vshCmdInfo` 还有处理函数 `cmdHelloWorld` 添加到 `domManagementCmds[]` 中。

    const vshCmdDef domManagementCmds[] = {
      ...
      {.name = "helloworld",
       .handler = cmdHelloWorld,
       .opts = opts_helloworld,
       .info = info_helloworld,
       .flags = 0
      },
      ...
    }

## 编译调试 libvirt 的一些技巧

centos 佩带的 libvirt 的 src.rpm 包的编译使用的是 spec 文件, 执行 `rpmbuild -ba libvirt.spec` 的时候会把配置、编译一气合成。

但当我们对自己修改的 libvirt 代码配置的时候，最好不要用 centos 的 spec 里的配置，如果按照 spec 里的配置，在启动我们的 libvirtd 的时候还要先执行 `systemctl stop libvirtd` 把系统的 libvirtd 的进程停掉。

所以下面分享一下我自己配置和调试 libvirt 的技巧。

### 配置、编译和安装过程

配置不加任何参数：

    .configure

编译就不用多说了：

    make -j 50

后面这步很重要，每次编译后，都要重新卸载再进行安装，否则新编译的代码可能不会出现在 libvirtd 当中。

    make uninstall
    make install

### 手动启动 libvirtd

libvirtd 是 libvirt 的守护进程，libvirt 的 API 接口几乎都是通过 RPC 调用链接到 libvirtd。virsh 命令就像一个 client 端，libvirtd 是服务端，virsh 的执行需要依靠 libvirtd。所以我们需要把 libvirtd 手动的拉起来。

    ./daemon/libvirtd&

### 使用的virsh 文件的路径

使用 `./tools/.libs/virsh` 命令行执行。

注意，用 gdb 跟踪时使用 `./tools/.libs/virsh`，不要使用 `./tools/virsh`，因为 `./tools/virsh` 只是个脚本。

## 执行结果

执行结果如下：

![alt figure1](D:\tinylab\tinylab.org\wp-content\uploads\2021\1\libvirt\figure1.png)

